Solved:

March 2023 (37): 
20 - 26, 121, 350
21 - 345, 347, 100, 572, 844
23 - 496, 232, 35, 14
24 - 278, 209
25 - 219
27 - 1, 605, 88, 49, 438
29 - 125, 20, 976, 21, 13, 560
30 - 28, 66, 70, 94, 101
31 - 67, 142, 704, 206, 226, 104

April 2023:
1 - 543
2 - 110, 118, 437, 122, 238, 53, 128
3 - 155, 1146
4 - 443
5 - 204, 11, 530, 15, 3, 347
6 - 268, 136, 338, 202




Done with help:
278 - In the binary search, the bounder should move to mid (not mid - 1) if we would like to include the index in the response
209 - Check the boundaries for left and right pointers with the array iteration
125 - Did not check alphanumeric part in the valid palindrome. manual implementation toLowerCase() is difficult
976 - Use sorting to maximise sum of elements in the array to get combination of numbers
13  - Iterating array or string from left to right, check what would be an approach iterating from right to left
560 - Using presum can be used to get the contigues subarrays sums
28  - To avoid overflow, use % 9999991 in operations
67  - To get a result from binary sum, use mod (%) and integer part of division
704 - Binary search for exact element left <= right and both pointers +/- 1. For upper/lower bound left = mid / right =mid
226 - Tree can be traversed iteratevely with stack or queue
1146- Red black tree can be used with the TreeMap (ceelingEntry, floorEntry)
204 - Bottom up approaches can be solved iteratevely or with precomputed arrays
11  - When there is no negative numbers in the array, you can use two pointers to maximaze the result, sum or area
530 - Recursion with inorder traverse and values can be an option using the class and private properties
